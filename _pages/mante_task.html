<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Context-Dependent Integration Task</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        
        #canvas {
            border: 2px solid #444;
            background: #000;
            cursor: crosshair;
        }
        
        .info {
            margin-top: 20px;
            text-align: center;
            font-size: 18px;
        }
        
        /* Reserve vertical space for two lines below the canvas */
        .info-line {
            min-height: 28px; /* ~1.5x of 18px to keep a full line even when empty */
            display: block;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #444;
            color: #fff;
            border: none;
            border-radius: 4px;
        }
        
        button:hover {
            background: #666;
        }
        
        .stats {
            margin-top: 20px;
            font-size: 14px;
            text-align: center;
        }
        
        .instructions {
            max-width: 800px;
            margin-bottom: 20px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .context-indicator {
            font-size: 20px;
            font-weight: bold;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="instructions">
        <h2>Context-Dependent Integration Task (Mante et al., 2013)</h2>
        <p><strong>Instructions:</strong></p>
        <ul>
            <li><strong>MOTION Context:</strong> Judge the direction of motion</li>
            <li><strong>COLOR Context:</strong> Judge the predominant color</li>
            <li>The context label is shown on the canvas</li>
        </ul>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>
    
    <div class="info">
        <div id="phase" class="info-line">Click the center circle to start</div>
        <div id="coherenceInfo" class="info-line" style="margin-top: 10px; font-size: 16px;"></div>
    </div>
    
    <div class="controls">
        <button id="resetBtn">Reset Stats</button>
    </div>
    
    <div class="stats">
        <div>Trials: <span id="trials">0</span> | Correct: <span id="correct">0</span> | Accuracy: <span id="accuracy">0%</span></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Task parameters
        const params = {
            fixationDuration: 300,
            targetsDuration: 350,
            dotsDuration: 750,
            delayDuration: 300,
            
            // Stimulus properties
            apertureRadius: 80,
            dotSize: 3,
            numDots: 200,
            dotSpeed: 2,
            
            // Positions
            centerX: canvas.width / 2,
            centerY: canvas.height / 2,
            targetEccentricity: 200,
            fixationSize: 10
        };
        
        // State
        let state = {
            phase: 'idle',
            context: null, // 'motion' or 'color'
            // Signed coherences in [-1, 1]; sign encodes direction/dominant color
            motionCoherence: 0,
            colorCoherence: 0,
            dots: [],
            leftTargetColor: null,
            rightTargetColor: null,
            correctTarget: null,
            responseAllowed: false,
            showStartButton: true,
            
            // Stats
            totalTrials: 0,
            correctTrials: 0
        };
        
        // Initialize next trial parameters immediately
        function prepareNextTrial() {
            // Random context
            state.context = Math.random() > 0.5 ? 'motion' : 'color';
            
            // Signed coherence levels (6 discrete, no zero)
            const levels = [-0.6, -0.3, -0.1, 0.1, 0.3, 0.6];
            state.motionCoherence = levels[Math.floor(Math.random() * levels.length)];
            state.colorCoherence = levels[Math.floor(Math.random() * levels.length)];
            
            // Random target configuration (randomize side assignment each trial)
            const leftIsRed = Math.random() > 0.5;
            state.leftTargetColor = leftIsRed ? 'red' : 'green';
            state.rightTargetColor = leftIsRed ? 'green' : 'red';
            
            // Determine correct target based on context and signed coherence
            if (state.context === 'motion') {
                // Right if motion coherence >= 0 (signal to the right), else left
                state.correctTarget = state.motionCoherence >= 0 ? 'right' : 'left';
            } else {
                const dominantColor = state.colorCoherence >= 0 ? 'red' : 'green';
                state.correctTarget = dominantColor === state.leftTargetColor ? 'left' : 'right';
            }
            
            // Initialize dots
            state.dots = [];
            for (let i = 0; i < params.numDots; i++) {
                state.dots.push(new Dot());
            }
            
            // Context info is shown on-canvas via drawContextLabel(); no below-canvas text
        }
        
        // Dot class
        class Dot {
            constructor() {
                this.reset();
                this.age = Math.random() * 30;
            }
            
            reset() {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * params.apertureRadius;
                this.x = params.centerX + r * Math.cos(angle);
                this.y = params.centerY + r * Math.sin(angle);
                // Assign color at reset based on signed color coherence
                const pRed = 0.5 * (1 + state.colorCoherence); // map [-1,1] to [0,1]
                this.color = Math.random() < pRed ? 'red' : 'green';
                this.age = 0;
            }
            
            update() {
                this.age++;
                if (this.age > 30) {
                    this.reset();
                    return;
                }
                
                // During stimulus, implement per-frame coherent displacement with prob |coh|
                const coh = Math.abs(state.motionCoherence);
                if (Math.random() < coh) {
                    const dx = state.motionCoherence >= 0 ? params.dotSpeed : -params.dotSpeed;
                    this.x += dx;
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    this.x += Math.cos(angle) * params.dotSpeed;
                    this.y += Math.sin(angle) * params.dotSpeed;
                }
                
                const dx0 = this.x - params.centerX;
                const dy0 = this.y - params.centerY;
                if (dx0*dx0 + dy0*dy0 > params.apertureRadius * params.apertureRadius) {
                    this.reset();
                }
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, params.dotSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function initializeTrial() {
            state.responseAllowed = false;
            state.showStartButton = false;
        }
        
        function drawFixation() {
            // Fixation point removed
        }
        
        function drawTargets() {
            // Left target
            ctx.fillStyle = state.leftTargetColor;
            ctx.beginPath();
            ctx.arc(params.centerX - params.targetEccentricity, params.centerY, 
                   20, 0, Math.PI * 2);
            ctx.fill();
            
            // Right target
            ctx.fillStyle = state.rightTargetColor;
            ctx.beginPath();
            ctx.arc(params.centerX + params.targetEccentricity, params.centerY, 
                   20, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawContextLabel() {
            if (state.context) {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const label = state.context.toUpperCase();
                ctx.fillText(label, params.centerX, params.centerY + params.apertureRadius + 60);
            }
        }
        
        function drawStartButton() {
            if (state.showStartButton) {
                // Draw semi-transparent circle as button
                ctx.fillStyle = 'rgba(100, 100, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(params.centerX, params.centerY, 50, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('START', params.centerX, params.centerY);
            }
        }
        
        function drawDots() {
            // Draw aperture
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(params.centerX, params.centerY, params.apertureRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Update and draw dots
            if (state.phase === 'dots') {
                state.dots.forEach(dot => {
                    dot.update();
                    dot.draw();
                });
            } else {
                // Still draw dots but stationary
                state.dots.forEach(dot => {
                    dot.draw();
                });
            }
        }
        
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Always show targets and upcoming context, including during START
            drawTargets();
            drawContextLabel();
            
            // Only show dots during the stimulus presentation phase
            if (state.phase === 'dots' && state.dots.length > 0) {
                drawDots();
            }
            
            // Draw start button if in idle state
            if (state.phase === 'idle' && state.showStartButton) {
                drawStartButton();
            }
        }
        
        async function runTrial() {
            initializeTrial();
            
            // Show initial state with context
            render();
            document.getElementById('phase').textContent = 'Get ready...';
            document.getElementById('coherenceInfo').textContent = '';
            await sleep(500);
            
            // Fixation
            state.phase = 'fixation';
            document.getElementById('phase').textContent = 'Focus on center';
            render();
            await sleep(params.fixationDuration);
            
            // Targets appear
            state.phase = 'targets';
            document.getElementById('phase').textContent = 'Targets appear';
            render();
            await sleep(params.targetsDuration);
            
            // Dots
            state.phase = 'dots';
            document.getElementById('phase').textContent = 'Viewing stimulus...';
            const dotsStart = Date.now();
            while (Date.now() - dotsStart < params.dotsDuration) {
                render();
                await sleep(16); // ~60fps
            }
            
            // Delay
            state.phase = 'delay';
            document.getElementById('phase').textContent = 'Delay...';
            render();
            await sleep(params.delayDuration);
            
            // Response period
            state.phase = 'response';
            state.responseAllowed = true;
            document.getElementById('phase').textContent = 'Click a target to respond!';
            render();
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function handleResponse(x, y) {
            // Check if clicking start button
            if (state.phase === 'idle' && state.showStartButton) {
                const distCenter = Math.sqrt((x - params.centerX)**2 + (y - params.centerY)**2);
                if (distCenter < 50) {
                    runTrial();
                    return;
                }
            }
            
            if (!state.responseAllowed || state.phase !== 'response') return;
            
            const leftTargetX = params.centerX - params.targetEccentricity;
            const rightTargetX = params.centerX + params.targetEccentricity;
            
            const distLeft = Math.sqrt((x - leftTargetX)**2 + (y - params.centerY)**2);
            const distRight = Math.sqrt((x - rightTargetX)**2 + (y - params.centerY)**2);
            
            let chosen = null;
            if (distLeft < 50) chosen = 'left';
            else if (distRight < 50) chosen = 'right';
            
            if (chosen) {
                state.responseAllowed = false;
                state.totalTrials++;
                
                const correct = chosen === state.correctTarget;
                if (correct) {
                    state.correctTrials++;
                    document.getElementById('phase').textContent = 'Correct!';
                    document.getElementById('phase').style.color = '#0f0';
                } else {
                    document.getElementById('phase').textContent = 'Incorrect';
                    document.getElementById('phase').style.color = '#f00';
                }
                
                // Show absolute coherences as decimals (no percent), e.g., 0.1
                const motionAbs = Math.abs(state.motionCoherence).toFixed(1);
                const colorAbs = Math.abs(state.colorCoherence).toFixed(1);
                document.getElementById('coherenceInfo').textContent = 
                    `Motion Coherence: ${motionAbs} | Color Coherence: ${colorAbs}`;
                
                updateStats();
                
                setTimeout(() => {
                    // Prepare next trial
                    prepareNextTrial();
                    document.getElementById('phase').textContent = 'Click the center circle to start next trial';
                    document.getElementById('phase').style.color = '#fff';
                    state.phase = 'idle';
                    state.showStartButton = true;
                    render();
                }, 1500);
            }
        }
        
        function updateStats() {
            document.getElementById('trials').textContent = state.totalTrials;
            document.getElementById('correct').textContent = state.correctTrials;
            const accuracy = state.totalTrials > 0 ? 
                Math.round(state.correctTrials / state.totalTrials * 100) : 0;
            document.getElementById('accuracy').textContent = accuracy + '%';
        }
        
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            handleResponse(x, y);
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            state.totalTrials = 0;
            state.correctTrials = 0;
            updateStats();
        });
        
        // Initial setup - prepare first trial
        prepareNextTrial();
        render();
    </script>
</body>
</html>
